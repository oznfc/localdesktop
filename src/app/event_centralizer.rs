use crate::app::build::WaylandBackend;
use crate::wayland::input::{
    RelativePosition, WinitInput, WinitKeyboardInputEvent, WinitMouseInputEvent,
    WinitMouseMovedEvent, WinitMouseWheelEvent, WinitTouchCancelledEvent, WinitTouchEndedEvent,
    WinitTouchMovedEvent, WinitTouchStartedEvent,
};
use crate::wayland::keymap::physicalkey_to_scancode;
use smithay::backend::input::InputEvent;
use smithay::utils::{Physical, Size};
use winit::event::{ElementState, Touch, TouchPhase, WindowEvent};

/// Specific events generated by Winit
#[derive(Debug)]
pub enum CentralizedEvent {
    /// The window has been resized
    Resized {
        /// The new physical size (in pixels)
        size: Size<i32, Physical>,
        /// The new scale factor
        scale_factor: f64,
    },

    /// The focus state of the window changed
    Focus(bool),

    /// An input event occurred.
    Input(InputEvent<WinitInput>),

    /// The user requested to close the window.
    CloseRequested,

    /// A redraw was requested
    Redraw,

    /// TODO: Support these events
    Unsupported,
}

pub fn centralize(event: WindowEvent, backend: &mut WaylandBackend) -> CentralizedEvent {
    let time = backend.clock.now().as_millis() as u64;
    return match event {
        WindowEvent::Resized(size) => {
            let (w, h): (i32, i32) = size.into();

            CentralizedEvent::Resized {
                size: (w, h).into(),
                scale_factor: backend.scale_factor,
            }
        }
        WindowEvent::ScaleFactorChanged {
            scale_factor: new_scale_factor,
            ..
        } => {
            backend.scale_factor = new_scale_factor;
            let (w, h): (i32, i32) = backend
                .graphic_renderer
                .as_ref()
                .unwrap()
                .window()
                .inner_size()
                .into();
            CentralizedEvent::Resized {
                size: (w, h).into(),
                scale_factor: backend.scale_factor,
            }
        }
        WindowEvent::RedrawRequested => CentralizedEvent::Redraw,
        WindowEvent::CloseRequested => CentralizedEvent::CloseRequested,
        WindowEvent::Focused(focused) => CentralizedEvent::Focus(focused),
        WindowEvent::KeyboardInput {
            event,
            is_synthetic,
            ..
        } if !is_synthetic && !event.repeat => {
            match event.state {
                ElementState::Pressed => backend.key_counter += 1,
                ElementState::Released => {
                    backend.key_counter = backend.key_counter.saturating_sub(1);
                }
            };

            let scancode = physicalkey_to_scancode(event.physical_key).unwrap_or(0);
            let event = InputEvent::Keyboard {
                event: WinitKeyboardInputEvent {
                    time,
                    key: scancode,
                    count: backend.key_counter,
                    state: event.state,
                },
            };
            CentralizedEvent::Input(event)
        }
        WindowEvent::CursorMoved { position, .. } => {
            let size = backend
                .graphic_renderer
                .as_ref()
                .unwrap()
                .window()
                .inner_size();
            let x = position.x / size.width as f64;
            let y = position.y / size.height as f64;
            let event = InputEvent::PointerMotionAbsolute {
                event: WinitMouseMovedEvent {
                    time,
                    position: RelativePosition::new(x, y),
                    global_position: position,
                },
            };
            CentralizedEvent::Input(event)
        }
        WindowEvent::MouseWheel { delta, .. } => {
            let event = InputEvent::PointerAxis {
                event: WinitMouseWheelEvent { time, delta },
            };
            CentralizedEvent::Input(event)
        }
        WindowEvent::MouseInput { state, button, .. } => {
            let event = InputEvent::PointerButton {
                event: WinitMouseInputEvent {
                    time,
                    button,
                    state,
                    is_x11: false,
                },
            };
            CentralizedEvent::Input(event)
        }
        WindowEvent::Touch(winit::event::Touch {
            phase: TouchPhase::Started,
            location,
            id,
            ..
        }) => {
            let size = backend
                .graphic_renderer
                .as_ref()
                .unwrap()
                .window()
                .inner_size();
            let x = location.x / size.width as f64;
            let y = location.y / size.width as f64;
            let event = InputEvent::TouchDown {
                event: WinitTouchStartedEvent {
                    time,
                    global_position: location,
                    position: RelativePosition::new(x, y),
                    id,
                },
            };

            CentralizedEvent::Input(event)
        }
        WindowEvent::Touch(Touch {
            phase: TouchPhase::Moved,
            location,
            id,
            ..
        }) => {
            let size = backend
                .graphic_renderer
                .as_ref()
                .unwrap()
                .window()
                .inner_size();
            let x = location.x / size.width as f64;
            let y = location.y / size.width as f64;
            let event = InputEvent::TouchMotion {
                event: WinitTouchMovedEvent {
                    time,
                    position: RelativePosition::new(x, y),
                    global_position: location,
                    id,
                },
            };

            CentralizedEvent::Input(event)
        }

        WindowEvent::Touch(Touch {
            phase: TouchPhase::Ended,
            location,
            id,
            ..
        }) => {
            let size = backend
                .graphic_renderer
                .as_ref()
                .unwrap()
                .window()
                .inner_size();
            let x = location.x / size.width as f64;
            let y = location.y / size.width as f64;
            let event = InputEvent::TouchMotion {
                event: WinitTouchMovedEvent {
                    time,
                    position: RelativePosition::new(x, y),
                    global_position: location,
                    id,
                },
            };
            (CentralizedEvent::Input(event));

            let event = InputEvent::TouchUp {
                event: WinitTouchEndedEvent { time, id },
            };

            CentralizedEvent::Input(event)
        }

        WindowEvent::Touch(Touch {
            phase: TouchPhase::Cancelled,
            id,
            ..
        }) => {
            let event = InputEvent::TouchCancel {
                event: WinitTouchCancelledEvent { time, id },
            };
            CentralizedEvent::Input(event)
        }
        _ => {
            log::info!("Unhandled event: {:?}", event);
            CentralizedEvent::Unsupported
        }
    };
}
